//
// -- Utilities
//

var fs = require('fs');
var os = require('os');
var spawn = require("child_process").spawn;

var hostname = os.hostname();

GLOBAL.dpc = function(t,fn) { if(typeof(t) == 'function') setTimeout(t,0); else setTimeout(fn,t); }

var UTILS = { }

UTILS.get_ts = function() {
    var ts = (new Date()).getTime();
    return ts;
}

UTILS.get_config = function(name) {

    var host_filename = __dirname + '/../config/'+name+'.'+hostname+'.cfg';
    var filename = __dirname + '/../config/'+name+'.cfg';

    var data = undefined;

    if(fs.existsSync(host_filename)) {
        data = fs.readFileSync(host_filename);
        console.log("Reading config:",host_filename);
    }
    else
    {
        data = fs.readFileSync(filename);
        console.log("Reading config:",filename);
    }

//  console.log(data.toString('utf-8'));
    return eval('('+data.toString('utf-8')+')');
}

UTILS.Logger = function(options)
{
    var self = this;
    var file = options.filename;

    self.write = function(text) {
        fs.appendFile(file, text);
    }
}

UTILS.Process = function(options)
{
    var self = this;
    self.options = options;
    self.relaunch = true;

    if(!options.descr)
        throw new Error("descr option is required");

    self.terminate = function()
    {
        if(self.process)
        {
            self.relaunch = false;
            self.process.kill('SIGTERM');
            delete self.process;
        }
        else
            console.error("Unable to terminate process, no process present");
    }

    self.restart = function()
    {
        if(self.process)
        {
            self.process.kill('SIGTERM');
        }
    }

    self.run = function()
    {
        if(self.process)
        {
            console.error(self.options);
            throw new Error("Process is already running!");
        }

        self.relaunch = true;
        self.process = spawn(self.options.process, self.options.args)

        if(0)
        {
            self.process.stdout.pipe(process.stdout);
            self.process.stderr.pipe(process.stderr);
            self.stdin = process.openStdin();
            self.stdin.pipe(self.process.stdin);
        }
        else
        {
            self.process.stdout.on('data',function (data)
            {
//                setTimeout(function(){ process.stdout.write(data); }, 1);
                process.stdout.write(data);
                if(options.logger)
                    options.logger.write(data);
//                console.log(''+data);
            });

            self.process.stderr.on('data',function (data)
            {
//                setTimeout(function(){ process.stderr.write(data); }, 1);
                process.stderr.write(data);
                if(options.logger)
                    options.logger.write(data);
//                console.error(''+data);
            });

            // ???
            self.stdin = process.openStdin();
            self.stdin.on('data', function(data) 
            {
                self.process.stdin.write(data);
            });

        }

        self.process.on('exit',function (code)
        {
            if(code)
            {
                console.log("WARNING - Child process '"+self.options.descr.toUpperCase()+"' exited with code "+code);
            }

            delete self.process;

            if(self.relaunch)
            {
                console.log("Restarting '"+self.options.descr.toUpperCase()+"'");
                dpc(self.run, options.restart_delay || 0);
            }
        });
    }
}

module.exports = UTILS;